#ifndef PROJECT_LIBRARY_H_
#define PROJECT_LIBRARY_H_

#include <stddef.h>
#include <unistd.h>
#include <stdio.h>
#include <allegro.h>
#include <iostream>
#include <cstdlib>
#include <vector>

#include "../leap/Leap.h"
#include "../leap/LeapMath.h"
#include "../state_machines/SX_Hand0_ert_rtw/SX_Hand0.h"                  /* Model's SX header file */
#include "../state_machines/DX_Hand_Fingers_ert_rtw/DX_Hand_Fingers.h"	  /* Model's DX header file */
#include "../state_machines/SX_Hand0_ert_rtw/rtwtypes.h"						/* Types generated by Simulink */
#include "../midi/midi_lib.h"
#include "../threads_managing/my_thread_lib.h"

// system midi port used
#define MIDI_PORT 5

// channels used for midi output
#define DX_HAND_CHANNEL 1
#define SX_HAND_CHANNEL 2
#define DRUMS_CHANNEL 3
#define BASS_CHANNEL 4

#define VOL_CHORD 50			// volume of playing chord
#define VOL_DRUM 50
#define VOL_MELODY 100

#define SM_INPUT_TYPE int_T		// new type used to SM input

#define V_CHANGE_CHORD 400		// module minimum sx velocity to change chord
#define MILLISEC_FILTER_SX 300		// filter between consecutive chords
#define MILLISEC_FILTER_DX 50
#define V_UP_DX 400				// module minimum dx velocity to change keyboard

#define KEY_INDEX 15			// number of notes in keyboard array
#define TON_INDEX 29			// number of notes in tonality array
#define FINGERS_DEEP 10			// deep [mm] to recognize a note with dx hand (no thumb)
#define THUMB_DEEP 20			// deep [mm] to recognize a note with dx thumb

#define LOWEST_A 57

//describes hands position
typedef struct
{
	int x;
	int y;
	int z;
} PointType;


typedef struct
{
	PointType position;
	int velocity;
} FingerType;

// output type of the sx controller acquisition function
typedef struct
{
	int id_frame;
	PointType position;
	PointType velocity;
	boolean_T is_sx_hand;
	int palm_normal;
}ControllerSxMsgType;

// output type of the dx controller acquisition function
typedef struct
{
	int id_frame;
	int thumb;
	int index;
	int middle;
	int ring;
	int pinky;
	int hand;
	int hand_speed;
	boolean_T init;
}ControllerDxMsgType;

// descriptor of a chord
typedef struct {
	int id;
	int volume;		// the same for all the note of the chord
	int note[4];	// coded note
	int control;	// 0: no chord | 1: chord
} chord_to_midi_Type;

// descriptor of a note
typedef struct {
	int id;
	int volume;		// the same for all the notes ot the chord
	int nota;		// 0: no note | others: coded note
} melody_to_midi_Type;

// types contains all information needed by dx and sx state machines
typedef struct {
	RT_MODEL_SX_Hand0_SymType SX_Hand0_M_;
	RT_MODEL_SX_Hand0_SymType *state = &SX_Hand0_M_;/* Real-time model */
	D_Work_SX_Hand0_SymType obs_states;/* Observable states */
	ExternalInputs_SX_Hand0_SymType input;/* External inputs */
	ExternalOutputs_SX_Hand_SymType output;/* External outputs */
} SxStateMachineVariablesType;

typedef struct {
	RT_MODEL_DX_Hand_Fingers_Sym DX_Hand_Fingers_M_;
	RT_MODEL_DX_Hand_Fingers_Sym *state = &DX_Hand_Fingers_M_;/* Real-time model */
	DW_DX_Hand_Fingers_Sym obs_states;/* Observable states */
	ExtU_DX_Hand_Fingers_Sym input;/* External inputs */
	ExtY_DX_Hand_Fingers_Sym output;/* External outputs */
} DxStateMachineVariablesType;

typedef struct {
	int id_sx;
	int rel_chord; // 1 -7 (grado in tonalita' dell'accordo da suonare)
	int keyboard[KEY_INDEX];
} SxMessageToGraphicType;

typedef struct {
	int id_dx;
	int n_semikey; // 1 - 3 (semitastiera da 5)
	int current_note; // 1 - (KEY_INDEX +1); 0: nessuna nota
} DxMessageToGraphicType;

typedef struct {
	char _1_[6];
	char _2_[6];
	char _3_[6];
	char _4_[6];
	char _5_[6];
	char _6_[6];
	char _7_[9];
} NamesChordType;


/*
 *
 * LOGIC FUNCTIONS
 *
 */

// initialize state machines
void initialize_msg_sx_sm(ExternalInputs_SX_Hand0_SymType*);

void initialize_msg_dx_sm(ExtU_DX_Hand_Fingers_Sym*);

// conversions 		controller msg -> state machines msg
boolean_T generate_msg_for_SX_statemachine(ControllerSxMsgType*,ExternalInputs_SX_Hand0_SymType*,int*);

boolean_T generate_msg_for_DX_statemachine(ControllerDxMsgType*,ExtU_DX_Hand_Fingers_Sym*,int*);

// conversions 		state machines msg -> our midi msg
boolean_T generate_notes_of_chord(ExternalOutputs_SX_Hand_SymType*, chord_to_midi_Type*);

boolean_T generate_notes_of_melody(ExtY_DX_Hand_Fingers_Sym*, melody_to_midi_Type*);


/*
 *
 * MIDI FUNCTIONS
 *
 */

void updating_midi_chord(RtMidiOut*,int,int,chord_to_midi_Type*,chord_to_midi_Type*);

void updating_midi_melody(RtMidiOut*,int,melody_to_midi_Type*,melody_to_midi_Type*);

int chord_on(RtMidiOut* midiout, int channel, chord_to_midi_Type* chord);

int chord_off(RtMidiOut* midiout, int channel, chord_to_midi_Type* chord);


/*
 *
 * THREADS
 *
 */

void* thread_hands_dx(void*);

void* thread_hands_sx(void*);

void* thread_drums(void*);


#endif /* PROJECT_LIBRARY_H_ */

